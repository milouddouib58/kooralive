# -*- coding: utf-8 -*-
import os
import json
import google.generativeai as genai


def _configure_gemini(api_key: str = None):
    """
    تهيئة مكتبة Gemini باستخدام مفتاح API.
    - إذا لم يتم تمرير api_key يتم البحث عنه في متغير البيئة GEMINI_API_KEY.
    """
    key = api_key or os.getenv("GEMINI_API_KEY")
    if not key:
        raise RuntimeError(
            "GEMINI_API_KEY غير مضبوط. "
            "ضعه في Secrets أو أدخله في الحقل داخل التطبيق."
        )
    genai.configure(api_key=key)


def analyze_with_gemini(
    payload: dict,
    api_key: str = None,
    model_name: str = "gemini-1.5-flash",
    temperature: float = 0.4,
    max_output_tokens: int = 1400,
    language: str = "ar",
    style: str = "مختصر وقابل للتنفيذ",
) -> str:
    """
    تحليل بيانات المراهنات باستخدام نموذج Gemini.
    
    Args:
        payload (dict): البيانات المراد تحليلها.
        api_key (str, optional): مفتاح Gemini API.
        model_name (str): اسم النموذج المستخدم.
        temperature (float): تحكم في تنوع الإجابة.
        max_output_tokens (int): الحد الأقصى لعدد الرموز الناتجة.
        language (str): لغة التحليل.
        style (str): أسلوب الكتابة.

    Returns:
        str: النص التحليلي الناتج من Gemini.
    """
    # تهيئة Gemini
    _configure_gemini(api_key)

    # تحميل النموذج
    model = genai.GenerativeModel(model_name)

    # تحويل البيانات إلى JSON مرتب
    json_blob = json.dumps(payload, ensure_ascii=False, indent=2)

    # --- البرومبت المطور ---
    prompt = f"""
    أنت محلل مراهنات رياضية وخبير في سرد البيانات، ومهمتك هي تحويل بيانات الأودز المعقدة إلى تحليل واضح وقابل للتنفيذ.
    البيانات المقدمة لك بصيغة JSON تحتوي على أسعار السوق المجمعة، والاحتمالات العادلة المحسوبة بعد إزالة هامش الربح (overround)، واقتراحات كيلي.
    استخدم هذه البيانات فقط لتقديم تحليل عميق باللغة "{language}" وبأسلوب "{style}".

    **اتبع خطوات التفكير التالية بدقة:**

    1.  **نظرة عامة على المباراة (Match Overview):** ابدأ بذكر الفريقين وتوقيت المباراة. ثم قدم ملخصًا سريعًا لما تشير إليه الاحتمالات العادلة (Fair Probs) بشكل عام (من هو المرشح، هل المباراة متقاربة؟).

    2.  **تحليل سوق 1x2 (نتيجة المباراة):**
        * قارن **الاحتمالات العادلة** (`fair_probs`) مع **أسعار السوق المجمعة** (`aggregated`).
        * حدد بوضوح أي فرصة "قيمة" (Value Bet). فرصة القيمة تحدث عندما يكون الاحتمال العادل لنتيجة ما أعلى بكثير من الاحتمال الضمني في سعر السوق (الاحتمال الضمني = 1 / السعر).
        * علّق على حجم الـ **Overround**. إذا كان مرتفعًا، فهذا يعني أن هامش ربح السوق كبير، والعكس صحيح.
        * حلل **اقتراحات كيلي** (`kelly_suggestions`). اشرح ماذا يعني "Edge" (الأفضلية) وحجم الرهان المقترح كنسبة من المحفظة. إذا لم تكن هناك اقتراحات، اذكر ذلك ووضح أن السوق لا يعرض أي أفضلية حسب المعايير المحددة.

    3.  **تحليل سوق الأهداف (Over/Under Totals):**
        * ركّز على **الخط المختار** (`selected_line`).
        * بنفس طريقة تحليل 1x2، قارن بين الاحتمالات العادلة لـ Over و Under وأسعار السوق.
        * ابحث عن أي فرصة "قيمة" في هذا السوق واشرحها.
        * حلل اقتراحات كيلي لهذا السوق إن وجدت.

    4.  **توصيات قابلة للتنفيذ (Actionable Recommendations):**
        * بناءً على تحليلك في الخطوات 2 و 3، قدم من 3 إلى 5 توصيات واضحة وموجزة.
        * يجب أن تكون كل توصية مدعومة بالبيانات (مثال: "التوصية: الرهان على فوز الفريق المضيف. السبب: تمثل الاحتمالات العادلة (55%) فرصة قيمة مقارنة بسعر السوق الذي يعكس احتمال 48% فقط").
        * اختتم بفقرة إخلاء مسؤولية قوية وواضحة، تؤكد أن هذا التحليل مبني على البيانات فقط وليس نصيحة مالية، وأن المراهنة مسؤولة تأتي مع مخاطر.

    **شروط صارمة للمخرجات:**
    -   **لا** تعد عرض بيانات JSON.
    -   استخدم تنسيق Markdown بشكل احترافي مع عناوين رئيسية (مثل "تحليل 1x2") ونقاط.
    -   استخدم الإيموجيز (🎯, 📊, 📈, ⚠️) لجعل التحليل سهل القراءة.
    -   تجنب اللغة الغامضة أو التكهنات. يجب أن يكون كل استنتاج مرتبطًا ببيانات محددة من JSON.

    **البيانات:**
    ```json
    {json_blob}
    ```
    """

    # استدعاء النموذج
    response = model.generate_content(
        prompt,
        generation_config={
            "temperature": temperature,
            "max_output_tokens": max_output_tokens,
        },
    )

    return response.text
